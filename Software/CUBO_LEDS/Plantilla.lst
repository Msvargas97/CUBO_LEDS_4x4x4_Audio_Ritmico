CCS PCH C Compiler, Version 4.120, 5729               06-dic.-15 10:20

               Filename: M:\PIC Projects\CUBO_LEDS\Plantilla.lst

               ROM used: 6196 bytes (5%)
                         Largest free fragment is 65528
               RAM used: 143 (4%) at main() level
                         183 (5%) worst case
               Stack:    5 worst case (4 in main + 1 for interrupts)

*
01000:  GOTO   23BA
*
01008:  MOVWF  04
0100A:  MOVFF  FD8,05
0100E:  MOVFF  FE0,06
01012:  MOVLB  0
01014:  MOVFF  FE9,0C
01018:  MOVFF  FEA,07
0101C:  MOVFF  FE1,08
01020:  MOVFF  FE2,09
01024:  MOVFF  FD9,0A
01028:  MOVFF  FDA,0B
0102C:  MOVFF  FF3,12
01030:  MOVFF  FF4,13
01034:  MOVFF  FFA,14
01038:  MOVFF  FF5,15
0103C:  MOVFF  FF6,16
01040:  MOVFF  FF7,17
01044:  MOVFF  FF8,18
01048:  MOVFF  FFB,19
0104C:  MOVFF  00,0E
01050:  MOVFF  01,0F
01054:  MOVFF  02,10
01058:  MOVFF  03,11
0105C:  BTFSS  FF2.5
0105E:  GOTO   1068
01062:  BTFSC  FF2.2
01064:  GOTO   10BE
01068:  MOVFF  0E,00
0106C:  MOVFF  0F,01
01070:  MOVFF  10,02
01074:  MOVFF  11,03
01078:  MOVFF  0C,FE9
0107C:  MOVFF  07,FEA
01080:  BSF    07.7
01082:  MOVFF  08,FE1
01086:  MOVFF  09,FE2
0108A:  MOVFF  0A,FD9
0108E:  MOVFF  0B,FDA
01092:  MOVFF  12,FF3
01096:  MOVFF  13,FF4
0109A:  MOVFF  14,FFA
0109E:  MOVFF  15,FF5
010A2:  MOVFF  16,FF6
010A6:  MOVFF  17,FF7
010AA:  MOVFF  18,FF8
010AE:  MOVFF  19,FFB
010B2:  MOVF   04,W
010B4:  MOVFF  06,FE0
010B8:  MOVFF  05,FD8
010BC:  RETFIE 0
.................... #include "EMm47J53_StackConfig.h" 
.................... /* 
.................... ** ########################################################################## 
.................... **     Filename  : EMm47J53_StackConfig.h 
.................... **     Processor : PIC18F47J53 
.................... **     FileFormat: V1.00 
.................... **     DataSheet : PIC18F47J53 
.................... **     Compiler  : CCS Compiler V4.114 
.................... **     Date/Time : 14.12.2011, 11:00 
.................... ** 
.................... ** 
.................... ** 
.................... ** 
.................... **     (c) Copyright OCTOPLUS.2008-2011 
.................... **     OCTOPLUS.  
.................... **     Ernesto Andres Rincon Cruz 
.................... **     Republica de Colombia 
.................... **     http      : www.octoplusaz.com 
.................... **     mail      : soporte@octoplusaz.com 
.................... **  
.................... ** 
.................... **     Nota:  Todas las funciones estan debidamente probadas usando el  
.................... **            modulo EMm47J53 corriendo a una frecuencia de bus interno  
.................... **            de 12MHz. Para mas informacion www.octoplusaz.com/foros 
.................... ** ########################################################################### 
.................... */ 
.................... #ifndef _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #define _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #include <18F47J53.h> 
.................... //////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... #device PIC18F47J53 
.................... #list 
....................  
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                     
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_INT    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
*
017DE:  MOVLW  01
017E0:  SUBWF  x8E,F
017E2:  BNC   17FC
017E4:  CLRF   FEA
017E6:  MOVLW  8E
017E8:  MOVWF  FE9
017EA:  MOVF   FEF,W
017EC:  BZ    17FC
017EE:  MOVLW  02
017F0:  MOVWF  00
017F2:  DECFSZ 00,F
017F4:  BRA    17F2
017F6:  BRA    17F8
017F8:  DECFSZ FEF,F
017FA:  BRA    17EE
017FC:  RETURN 0
....................  
.................... #pin_select U2TX=PIN_D2 //Selecciona hardware UART2 
.................... #pin_select U2RX=PIN_D3 //Selecciona hardware UART2 
....................  
....................  
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
....................  
.................... #bit PLLEN = 0xf9b.6 
....................  
.................... #define mcu_init()\ 
.................... do{\ 
....................  PLLEN = 1;          /*Habilita PLL para generar 48MHz de oscilador*/\ 
.................... }while(0) 
....................  
.................... #endif /* _INC_OCTOPLUS_STACK_CONFIG_H */ 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0208C:  BCF    xA2.0
....................    y = x; 
0208E:  MOVFF  96,9B
02092:  MOVFF  95,9A
02096:  MOVFF  94,99
0209A:  MOVFF  93,98
....................  
....................    if (x < 0) 
0209E:  MOVFF  96,A6
020A2:  MOVFF  95,A5
020A6:  MOVFF  94,A4
020AA:  MOVFF  93,A3
020AE:  CLRF   xAA
020B0:  CLRF   xA9
020B2:  CLRF   xA8
020B4:  CLRF   xA7
020B6:  RCALL  1C82
020B8:  BNC   20C2
....................    { 
....................       s = 1; 
020BA:  BSF    xA2.0
....................       y = -y; 
020BC:  MOVF   x99,W
020BE:  XORLW  80
020C0:  MOVWF  x99
....................    } 
....................  
....................    if (y <= 32768.0) 
020C2:  MOVFF  9B,A6
020C6:  MOVFF  9A,A5
020CA:  MOVFF  99,A4
020CE:  MOVFF  98,A3
020D2:  CLRF   xAA
020D4:  CLRF   xA9
020D6:  CLRF   xA8
020D8:  MOVLW  8E
020DA:  MOVWF  xA7
020DC:  RCALL  1C82
020DE:  BC    20E2
020E0:  BNZ   2110
....................       res = (float32)(unsigned int16)y; 
020E2:  MOVFF  9B,A6
020E6:  MOVFF  9A,A5
020EA:  MOVFF  99,A4
020EE:  MOVFF  98,A3
020F2:  RCALL  1CF8
020F4:  MOVFF  02,A8
020F8:  MOVFF  01,A7
020FC:  RCALL  1C4C
020FE:  MOVFF  03,9F
02102:  MOVFF  02,9E
02106:  MOVFF  01,9D
0210A:  MOVFF  00,9C
....................  
....................  else if (y < 10000000.0) 
0210E:  BRA    228A
02110:  MOVFF  9B,A6
02114:  MOVFF  9A,A5
02118:  MOVFF  99,A4
0211C:  MOVFF  98,A3
02120:  MOVLW  80
02122:  MOVWF  xAA
02124:  MOVLW  96
02126:  MOVWF  xA9
02128:  MOVLW  18
0212A:  MOVWF  xA8
0212C:  MOVLW  96
0212E:  MOVWF  xA7
02130:  RCALL  1C82
02132:  BTFSS  FD8.0
02134:  BRA    227A
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
02136:  MOVFF  9B,A6
0213A:  MOVFF  9A,A5
0213E:  MOVFF  99,A4
02142:  MOVFF  98,A3
02146:  CLRF   xAA
02148:  CLRF   xA9
0214A:  CLRF   xA8
0214C:  MOVLW  70
0214E:  MOVWF  xA7
02150:  RCALL  1D30
02152:  MOVFF  03,A6
02156:  MOVFF  02,A5
0215A:  MOVFF  01,A4
0215E:  MOVFF  00,A3
02162:  RCALL  1CF8
02164:  MOVFF  02,A1
02168:  MOVFF  01,A0
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0216C:  MOVFF  9B,A6
02170:  MOVFF  9A,A5
02174:  MOVFF  99,A4
02178:  MOVFF  98,A3
0217C:  CLRF   xAA
0217E:  CLRF   xA9
02180:  CLRF   xA8
02182:  MOVLW  70
02184:  MOVWF  xA7
02186:  RCALL  1D30
02188:  MOVFF  00,A3
0218C:  MOVFF  01,A4
02190:  MOVFF  02,A5
02194:  MOVFF  03,A6
02198:  MOVFF  A1,A8
0219C:  MOVFF  A0,A7
021A0:  RCALL  1C4C
021A2:  BSF    FD8.1
021A4:  MOVFF  A6,AA
021A8:  MOVFF  A5,A9
021AC:  MOVFF  A4,A8
021B0:  MOVFF  A3,A7
021B4:  MOVFF  03,AE
021B8:  MOVFF  02,AD
021BC:  MOVFF  01,AC
021C0:  MOVFF  00,AB
021C4:  RCALL  1E22
021C6:  CLRF   xA6
021C8:  CLRF   xA5
021CA:  CLRF   xA4
021CC:  MOVLW  8E
021CE:  MOVWF  xA3
021D0:  MOVFF  03,AA
021D4:  MOVFF  02,A9
021D8:  MOVFF  01,A8
021DC:  MOVFF  00,A7
021E0:  RCALL  1D30
021E2:  MOVFF  03,9B
021E6:  MOVFF  02,9A
021EA:  MOVFF  01,99
021EE:  MOVFF  00,98
....................       res = 32768.0*(float32)l; 
021F2:  MOVFF  A1,A8
021F6:  MOVFF  A0,A7
021FA:  RCALL  1C4C
021FC:  CLRF   xA6
021FE:  CLRF   xA5
02200:  CLRF   xA4
02202:  MOVLW  8E
02204:  MOVWF  xA3
02206:  MOVFF  03,AA
0220A:  MOVFF  02,A9
0220E:  MOVFF  01,A8
02212:  MOVFF  00,A7
02216:  RCALL  1D30
02218:  MOVFF  03,9F
0221C:  MOVFF  02,9E
02220:  MOVFF  01,9D
02224:  MOVFF  00,9C
....................       res += (float32)(unsigned int16)y; 
02228:  MOVFF  9B,A6
0222C:  MOVFF  9A,A5
02230:  MOVFF  99,A4
02234:  MOVFF  98,A3
02238:  RCALL  1CF8
0223A:  MOVFF  02,A8
0223E:  MOVFF  01,A7
02242:  RCALL  1C4C
02244:  BCF    FD8.1
02246:  MOVFF  9F,AA
0224A:  MOVFF  9E,A9
0224E:  MOVFF  9D,A8
02252:  MOVFF  9C,A7
02256:  MOVFF  03,AE
0225A:  MOVFF  02,AD
0225E:  MOVFF  01,AC
02262:  MOVFF  00,AB
02266:  RCALL  1E22
02268:  MOVFF  03,9F
0226C:  MOVFF  02,9E
02270:  MOVFF  01,9D
02274:  MOVFF  00,9C
....................    } 
....................  
....................  else 
02278:  BRA    228A
....................   res = y; 
0227A:  MOVFF  9B,9F
0227E:  MOVFF  9A,9E
02282:  MOVFF  99,9D
02286:  MOVFF  98,9C
....................  
....................  y = y - (float32)(unsigned int16)y; 
0228A:  MOVFF  9B,A6
0228E:  MOVFF  9A,A5
02292:  MOVFF  99,A4
02296:  MOVFF  98,A3
0229A:  RCALL  1CF8
0229C:  MOVFF  02,A8
022A0:  MOVFF  01,A7
022A4:  RCALL  1C4C
022A6:  BSF    FD8.1
022A8:  MOVFF  9B,AA
022AC:  MOVFF  9A,A9
022B0:  MOVFF  99,A8
022B4:  MOVFF  98,A7
022B8:  MOVFF  03,AE
022BC:  MOVFF  02,AD
022C0:  MOVFF  01,AC
022C4:  MOVFF  00,AB
022C8:  RCALL  1E22
022CA:  MOVFF  03,9B
022CE:  MOVFF  02,9A
022D2:  MOVFF  01,99
022D6:  MOVFF  00,98
....................  
....................  if (s) 
022DA:  BTFSS  xA2.0
022DC:  BRA    22E4
....................   res = -res; 
022DE:  MOVF   x9D,W
022E0:  XORLW  80
022E2:  MOVWF  x9D
....................  
....................  if (y != 0) 
022E4:  MOVFF  9B,A6
022E8:  MOVFF  9A,A5
022EC:  MOVFF  99,A4
022F0:  MOVFF  98,A3
022F4:  CLRF   xAA
022F6:  CLRF   xA9
022F8:  CLRF   xA8
022FA:  CLRF   xA7
022FC:  RCALL  1C82
022FE:  BZ    236C
....................  { 
....................   if (s == 1 && n == 0) 
02300:  BTFSS  xA2.0
02302:  BRA    2336
02304:  MOVF   x97,F
02306:  BNZ   2336
....................    res -= 1.0; 
02308:  BSF    FD8.1
0230A:  MOVFF  9F,AA
0230E:  MOVFF  9E,A9
02312:  MOVFF  9D,A8
02316:  MOVFF  9C,A7
0231A:  CLRF   xAE
0231C:  CLRF   xAD
0231E:  CLRF   xAC
02320:  MOVLW  7F
02322:  MOVWF  xAB
02324:  RCALL  1E22
02326:  MOVFF  03,9F
0232A:  MOVFF  02,9E
0232E:  MOVFF  01,9D
02332:  MOVFF  00,9C
....................  
....................   if (s == 0 && n == 1) 
02336:  BTFSC  xA2.0
02338:  BRA    236C
0233A:  DECFSZ x97,W
0233C:  BRA    236C
....................    res += 1.0; 
0233E:  BCF    FD8.1
02340:  MOVFF  9F,AA
02344:  MOVFF  9E,A9
02348:  MOVFF  9D,A8
0234C:  MOVFF  9C,A7
02350:  CLRF   xAE
02352:  CLRF   xAD
02354:  CLRF   xAC
02356:  MOVLW  7F
02358:  MOVWF  xAB
0235A:  RCALL  1E22
0235C:  MOVFF  03,9F
02360:  MOVFF  02,9E
02364:  MOVFF  01,9D
02368:  MOVFF  00,9C
....................  } 
....................  if (x == 0) 
0236C:  MOVFF  96,A6
02370:  MOVFF  95,A5
02374:  MOVFF  94,A4
02378:  MOVFF  93,A3
0237C:  CLRF   xAA
0237E:  CLRF   xA9
02380:  CLRF   xA8
02382:  CLRF   xA7
02384:  RCALL  1C82
02386:  BNZ   2390
....................     res = 0; 
02388:  CLRF   x9F
0238A:  CLRF   x9E
0238C:  CLRF   x9D
0238E:  CLRF   x9C
....................  
....................  return (res); 
02390:  MOVFF  9C,00
02394:  MOVFF  9D,01
02398:  MOVFF  9E,02
0239C:  MOVFF  9F,03
.................... } 
023A0:  GOTO   23B8 (RETURN)
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
023A4:  MOVFF  92,96
023A8:  MOVFF  91,95
023AC:  MOVFF  90,94
023B0:  MOVFF  8F,93
023B4:  CLRF   x97
023B6:  BRA    208C
.................... } 
023B8:  RETURN 0
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************/ 
.................... /*------- Espacio para declaracion de constantes  ------*/ 
.................... /********************************************************/ 
.................... #define LED4 PIN_C7 
.................... #define LED3 PIN_C6 
.................... #define LED2 PIN_C2 
.................... #define LED1 PIN_C1 
.................... #define LED8 PIN_C0 
.................... #define LED7 PIN_D7 
.................... #define LED6 PIN_D6 
.................... #define LED5 PIN_D5 
.................... #define LED9 PIN_D4 
.................... #define LED10 PIN_D3 
.................... #define LED11 PIN_D2 
.................... #define LED12 PIN_E0 
.................... #define LED13 PIN_E1 
.................... #define LED14 PIN_E2 
.................... #define LED15 PIN_B0 
.................... #define LED16 PIN_B1 
.................... #define PISO1 PIN_B7 
.................... #define PISO2 PIN_B6 
.................... #define PISO3 PIN_B5 
.................... #define PISO4 PIN_B4  
.................... #define time 200 //el tiempo de multiplexacion 
....................  
.................... /********************************************************/ 
.................... /*--- Espacio para declaracion de variables globales  --*/ 
.................... /********************************************************/ 
.................... unsigned INT16 LEDS[16]={LED1,LED2,LED3,LED4,LED5,LED6,LED7,LED8,LED9,LED10,LED11,LED12,LED13,LED14,LED15,LED16}; 
.................... unsigned INT16 pisos[4]={PISO1,PISO2,PISO3,PISO4}; 
.................... const UNSIGNED int8 num[4]={0b0001,0b0011,0b0111,0b1111}; 
.................... unsigned INT16 i=0,j=0,k=0,h=0,m=0,sound,speed; 
.................... unsigned INT16  mic=0; 
.................... unsigned INT16 timeRefresh=0,animation=0; 
.................... volatile UNSIGNED int16 sample,peakToPeak; 
.................... int1 reverse=0,change=0,enable=0,positionBits=1; 
....................   UNSIGNED int signalMax = 0; 
....................   UNSIGNED int signalMin = 256; 
.................... unsigned INT8 vector[4]={0b0001,0b0010,0b0100,0b1000}; 
.................... /********************************************************/ 
.................... /********************************************************/ 
.................... /*-------------- Espacio para funciones  ---------------*/ 
.................... /********************************************************/ 
.................... #define min(a,b) ((a)<(b)?(a):(b)) 
.................... #define max(a,b) ((a)>(b)?(a):(b)) 
.................... #define abs(x) ((x)>0?(x):-(x)) 
.................... #define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt))) 
.................... #define round(x)     ((x)>=0?(LONG)((x)+0.5):(long)((x)-0.5)) 
.................... #define lowByte(w) ((uint8_t) ((w) & 0xff)) 
.................... #define highByte(w) ((uint8_t) ((w) >> 8)) 
.................... #define bitRead(value, bit) (((value) >> (bit)) & 0x01) 
.................... #define bitSet(value, bit) ((value) |= (1UL << (bit))) 
.................... #define bitClear(value, bit) ((value) &= ~(1UL << (bit))) 
.................... #define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit)) 
....................  
.................... void off_leds(VOID) 
.................... { 
....................    //Esta funcin apaga los leds 
....................    FOR (i = 0; i < 16; i++) 
*
013F6:  CLRF   4A
013F8:  CLRF   49
013FA:  MOVF   4A,F
013FC:  BNZ   144C
013FE:  MOVF   49,W
01400:  SUBLW  0F
01402:  BNC   144C
....................    { 
....................       output_low (LEDS[i]); 
01404:  BCF    FD8.0
01406:  RLCF   49,W
01408:  MOVWF  02
0140A:  RLCF   4A,W
0140C:  MOVWF  03
0140E:  MOVF   02,W
01410:  ADDLW  21
01412:  MOVWF  FE9
01414:  MOVLW  00
01416:  ADDWFC 03,W
01418:  MOVWF  FEA
0141A:  MOVFF  FEC,8F
0141E:  MOVF   FED,F
01420:  MOVFF  FEF,8E
01424:  MOVFF  8E,93
01428:  CLRF   x94
0142A:  MOVLW  0F
0142C:  MOVWF  x96
0142E:  MOVLW  89
01430:  MOVWF  x95
01432:  RCALL  13B8
01434:  MOVFF  8E,93
01438:  CLRF   x94
0143A:  MOVLW  0F
0143C:  MOVWF  x96
0143E:  MOVLW  92
01440:  MOVWF  x95
01442:  RCALL  13B8
....................    } 
01444:  INCF   49,F
01446:  BTFSC  FD8.2
01448:  INCF   4A,F
0144A:  BRA    13FA
....................  
....................    output_low (pisos[0]); 
0144C:  MOVFF  41,93
01450:  CLRF   x94
01452:  MOVLW  0F
01454:  MOVWF  x96
01456:  MOVLW  89
01458:  MOVWF  x95
0145A:  RCALL  13B8
0145C:  MOVFF  41,93
01460:  CLRF   x94
01462:  MOVLW  0F
01464:  MOVWF  x96
01466:  MOVLW  92
01468:  MOVWF  x95
0146A:  RCALL  13B8
....................    output_low (pisos[1]); 
0146C:  MOVFF  43,93
01470:  CLRF   x94
01472:  MOVLW  0F
01474:  MOVWF  x96
01476:  MOVLW  89
01478:  MOVWF  x95
0147A:  RCALL  13B8
0147C:  MOVFF  43,93
01480:  CLRF   x94
01482:  MOVLW  0F
01484:  MOVWF  x96
01486:  MOVLW  92
01488:  MOVWF  x95
0148A:  RCALL  13B8
....................    output_low (pisos[2]); 
0148C:  MOVFF  45,93
01490:  CLRF   x94
01492:  MOVLW  0F
01494:  MOVWF  x96
01496:  MOVLW  89
01498:  MOVWF  x95
0149A:  RCALL  13B8
0149C:  MOVFF  45,93
014A0:  CLRF   x94
014A2:  MOVLW  0F
014A4:  MOVWF  x96
014A6:  MOVLW  92
014A8:  MOVWF  x95
014AA:  RCALL  13B8
....................    output_low (pisos[3]); 
014AC:  MOVFF  47,93
014B0:  CLRF   x94
014B2:  MOVLW  0F
014B4:  MOVWF  x96
014B6:  MOVLW  89
014B8:  MOVWF  x95
014BA:  RCALL  13B8
014BC:  MOVFF  47,93
014C0:  CLRF   x94
014C2:  MOVLW  0F
014C4:  MOVWF  x96
014C6:  MOVLW  92
014C8:  MOVWF  x95
014CA:  RCALL  13B8
.................... } 
014CC:  RETURN 0
....................  
.................... int1 reordernar() 
.................... { 
....................    positionBits = ! positionBits; 
*
010D0:  BTG    x61.3
....................    STATIC int16 aux[16]; 
....................    STATIC int8 factor; 
....................    FOR (i = 0; i < 16; i++) 
010D2:  CLRF   4A
010D4:  CLRF   49
010D6:  MOVF   4A,F
010D8:  BNZ   1132
010DA:  MOVF   49,W
010DC:  SUBLW  0F
010DE:  BNC   1132
....................    { 
....................       //Hacer una copia del vector 
....................       aux[i] = LEDS[i]; 
010E0:  BCF    FD8.0
010E2:  RLCF   49,W
010E4:  MOVWF  02
010E6:  RLCF   4A,W
010E8:  MOVWF  03
010EA:  MOVF   02,W
010EC:  ADDLW  68
010EE:  MOVWF  01
010F0:  MOVLW  00
010F2:  ADDWFC 03,F
010F4:  MOVFF  03,8C
010F8:  BCF    FD8.0
010FA:  RLCF   49,W
010FC:  MOVWF  02
010FE:  RLCF   4A,W
01100:  MOVWF  03
01102:  MOVF   02,W
01104:  ADDLW  21
01106:  MOVWF  FE9
01108:  MOVLW  00
0110A:  ADDWFC 03,W
0110C:  MOVWF  FEA
0110E:  MOVFF  FEC,03
01112:  MOVF   FED,F
01114:  MOVFF  FEF,8D
01118:  MOVFF  8C,FEA
0111C:  MOVFF  01,FE9
01120:  MOVFF  03,FEC
01124:  MOVF   FED,F
01126:  MOVFF  8D,FEF
....................    } 
0112A:  INCF   49,F
0112C:  BTFSC  FD8.2
0112E:  INCF   4A,F
01130:  BRA    10D6
....................  
....................    h = 0; 
01132:  CLRF   50
01134:  CLRF   4F
....................    FOR (i = 3; i < 16; i = i + 4) 
01136:  CLRF   4A
01138:  MOVLW  03
0113A:  MOVWF  49
0113C:  MOVF   4A,F
0113E:  BNZ   11A0
01140:  MOVF   49,W
01142:  SUBLW  0F
01144:  BNC   11A0
....................    { 
....................       //Reodernar 
....................       LEDS[h] = aux[i]; 
01146:  BCF    FD8.0
01148:  RLCF   4F,W
0114A:  MOVWF  02
0114C:  RLCF   50,W
0114E:  MOVWF  03
01150:  MOVF   02,W
01152:  ADDLW  21
01154:  MOVWF  01
01156:  MOVLW  00
01158:  ADDWFC 03,F
0115A:  MOVFF  03,8C
0115E:  BCF    FD8.0
01160:  RLCF   49,W
01162:  MOVWF  02
01164:  RLCF   4A,W
01166:  MOVWF  03
01168:  MOVF   02,W
0116A:  ADDLW  68
0116C:  MOVWF  FE9
0116E:  MOVLW  00
01170:  ADDWFC 03,W
01172:  MOVWF  FEA
01174:  MOVFF  FEC,03
01178:  MOVF   FED,F
0117A:  MOVFF  FEF,8D
0117E:  MOVFF  8C,FEA
01182:  MOVFF  01,FE9
01186:  MOVFF  03,FEC
0118A:  MOVF   FED,F
0118C:  MOVFF  8D,FEF
....................       h++; 
01190:  INCF   4F,F
01192:  BTFSC  FD8.2
01194:  INCF   50,F
....................    } 
01196:  MOVLW  04
01198:  ADDWF  49,F
0119A:  MOVLW  00
0119C:  ADDWFC 4A,F
0119E:  BRA    113C
....................  
....................    FOR (i = 2; i < 15; i = i + 4) 
011A0:  CLRF   4A
011A2:  MOVLW  02
011A4:  MOVWF  49
011A6:  MOVF   4A,F
011A8:  BNZ   120A
011AA:  MOVF   49,W
011AC:  SUBLW  0E
011AE:  BNC   120A
....................    { 
....................       //Reodernar 
....................       LEDS[h] = aux[i]; 
011B0:  BCF    FD8.0
011B2:  RLCF   4F,W
011B4:  MOVWF  02
011B6:  RLCF   50,W
011B8:  MOVWF  03
011BA:  MOVF   02,W
011BC:  ADDLW  21
011BE:  MOVWF  01
011C0:  MOVLW  00
011C2:  ADDWFC 03,F
011C4:  MOVFF  03,8C
011C8:  BCF    FD8.0
011CA:  RLCF   49,W
011CC:  MOVWF  02
011CE:  RLCF   4A,W
011D0:  MOVWF  03
011D2:  MOVF   02,W
011D4:  ADDLW  68
011D6:  MOVWF  FE9
011D8:  MOVLW  00
011DA:  ADDWFC 03,W
011DC:  MOVWF  FEA
011DE:  MOVFF  FEC,03
011E2:  MOVF   FED,F
011E4:  MOVFF  FEF,8D
011E8:  MOVFF  8C,FEA
011EC:  MOVFF  01,FE9
011F0:  MOVFF  03,FEC
011F4:  MOVF   FED,F
011F6:  MOVFF  8D,FEF
....................       h++; 
011FA:  INCF   4F,F
011FC:  BTFSC  FD8.2
011FE:  INCF   50,F
....................    } 
01200:  MOVLW  04
01202:  ADDWF  49,F
01204:  MOVLW  00
01206:  ADDWFC 4A,F
01208:  BRA    11A6
....................  
....................    FOR (i = 1; i < 14; i = i + 4) 
0120A:  CLRF   4A
0120C:  MOVLW  01
0120E:  MOVWF  49
01210:  MOVF   4A,F
01212:  BNZ   1274
01214:  MOVF   49,W
01216:  SUBLW  0D
01218:  BNC   1274
....................    { 
....................       //Reodernar 
....................       LEDS[h] = aux[i]; 
0121A:  BCF    FD8.0
0121C:  RLCF   4F,W
0121E:  MOVWF  02
01220:  RLCF   50,W
01222:  MOVWF  03
01224:  MOVF   02,W
01226:  ADDLW  21
01228:  MOVWF  01
0122A:  MOVLW  00
0122C:  ADDWFC 03,F
0122E:  MOVFF  03,8C
01232:  BCF    FD8.0
01234:  RLCF   49,W
01236:  MOVWF  02
01238:  RLCF   4A,W
0123A:  MOVWF  03
0123C:  MOVF   02,W
0123E:  ADDLW  68
01240:  MOVWF  FE9
01242:  MOVLW  00
01244:  ADDWFC 03,W
01246:  MOVWF  FEA
01248:  MOVFF  FEC,03
0124C:  MOVF   FED,F
0124E:  MOVFF  FEF,8D
01252:  MOVFF  8C,FEA
01256:  MOVFF  01,FE9
0125A:  MOVFF  03,FEC
0125E:  MOVF   FED,F
01260:  MOVFF  8D,FEF
....................       h++; 
01264:  INCF   4F,F
01266:  BTFSC  FD8.2
01268:  INCF   50,F
....................    } 
0126A:  MOVLW  04
0126C:  ADDWF  49,F
0126E:  MOVLW  00
01270:  ADDWFC 4A,F
01272:  BRA    1210
....................  
....................    FOR (i = 0; i < 13; i = i + 4) 
01274:  CLRF   4A
01276:  CLRF   49
01278:  MOVF   4A,F
0127A:  BNZ   12DC
0127C:  MOVF   49,W
0127E:  SUBLW  0C
01280:  BNC   12DC
....................    { 
....................       //Reodernar 
....................       LEDS[h] = aux[i]; 
01282:  BCF    FD8.0
01284:  RLCF   4F,W
01286:  MOVWF  02
01288:  RLCF   50,W
0128A:  MOVWF  03
0128C:  MOVF   02,W
0128E:  ADDLW  21
01290:  MOVWF  01
01292:  MOVLW  00
01294:  ADDWFC 03,F
01296:  MOVFF  03,8C
0129A:  BCF    FD8.0
0129C:  RLCF   49,W
0129E:  MOVWF  02
012A0:  RLCF   4A,W
012A2:  MOVWF  03
012A4:  MOVF   02,W
012A6:  ADDLW  68
012A8:  MOVWF  FE9
012AA:  MOVLW  00
012AC:  ADDWFC 03,W
012AE:  MOVWF  FEA
012B0:  MOVFF  FEC,03
012B4:  MOVF   FED,F
012B6:  MOVFF  FEF,8D
012BA:  MOVFF  8C,FEA
012BE:  MOVFF  01,FE9
012C2:  MOVFF  03,FEC
012C6:  MOVF   FED,F
012C8:  MOVFF  8D,FEF
....................       h++; 
012CC:  INCF   4F,F
012CE:  BTFSC  FD8.2
012D0:  INCF   50,F
....................    } 
012D2:  MOVLW  04
012D4:  ADDWF  49,F
012D6:  MOVLW  00
012D8:  ADDWFC 4A,F
012DA:  BRA    1278
....................  
....................    RETURN positionBits; 
012DC:  MOVLW  00
012DE:  BTFSC  x61.3
012E0:  MOVLW  01
012E2:  MOVWF  01
.................... } 
012E4:  RETURN 0
....................  
.................... void piso(j) 
.................... { 
....................    // esta funcion escoge el piso que se desea encender 
....................    SWITCH (j) 
....................    { 
*
014CE:  MOVF   x91,W
014D0:  ADDLW  FC
014D2:  BTFSC  FD8.0
014D4:  BRA    16EC
014D6:  ADDLW  04
014D8:  GOTO   16F0
....................       CASE 0: 
....................       output_high (pisos[0]); 
014DC:  MOVFF  41,93
014E0:  MOVLW  01
014E2:  MOVWF  x94
014E4:  MOVLW  0F
014E6:  MOVWF  x96
014E8:  MOVLW  89
014EA:  MOVWF  x95
014EC:  RCALL  13B8
014EE:  MOVFF  41,93
014F2:  CLRF   x94
014F4:  MOVLW  0F
014F6:  MOVWF  x96
014F8:  MOVLW  92
014FA:  MOVWF  x95
014FC:  RCALL  13B8
....................       output_low (pisos[1]); 
014FE:  MOVFF  43,93
01502:  CLRF   x94
01504:  MOVLW  0F
01506:  MOVWF  x96
01508:  MOVLW  89
0150A:  MOVWF  x95
0150C:  RCALL  13B8
0150E:  MOVFF  43,93
01512:  CLRF   x94
01514:  MOVLW  0F
01516:  MOVWF  x96
01518:  MOVLW  92
0151A:  MOVWF  x95
0151C:  RCALL  13B8
....................       output_low (pisos[2]); 
0151E:  MOVFF  45,93
01522:  CLRF   x94
01524:  MOVLW  0F
01526:  MOVWF  x96
01528:  MOVLW  89
0152A:  MOVWF  x95
0152C:  RCALL  13B8
0152E:  MOVFF  45,93
01532:  CLRF   x94
01534:  MOVLW  0F
01536:  MOVWF  x96
01538:  MOVLW  92
0153A:  MOVWF  x95
0153C:  RCALL  13B8
....................       output_low (pisos[3]); 
0153E:  MOVFF  47,93
01542:  CLRF   x94
01544:  MOVLW  0F
01546:  MOVWF  x96
01548:  MOVLW  89
0154A:  MOVWF  x95
0154C:  RCALL  13B8
0154E:  MOVFF  47,93
01552:  CLRF   x94
01554:  MOVLW  0F
01556:  MOVWF  x96
01558:  MOVLW  92
0155A:  MOVWF  x95
0155C:  RCALL  13B8
....................       BREAK; 
0155E:  BRA    16EC
....................  
....................       CASE 1: 
....................       output_high (pisos[1]); 
01560:  MOVFF  43,93
01564:  MOVLW  01
01566:  MOVWF  x94
01568:  MOVLW  0F
0156A:  MOVWF  x96
0156C:  MOVLW  89
0156E:  MOVWF  x95
01570:  RCALL  13B8
01572:  MOVFF  43,93
01576:  CLRF   x94
01578:  MOVLW  0F
0157A:  MOVWF  x96
0157C:  MOVLW  92
0157E:  MOVWF  x95
01580:  RCALL  13B8
....................       output_low (pisos[0]); 
01582:  MOVFF  41,93
01586:  CLRF   x94
01588:  MOVLW  0F
0158A:  MOVWF  x96
0158C:  MOVLW  89
0158E:  MOVWF  x95
01590:  RCALL  13B8
01592:  MOVFF  41,93
01596:  CLRF   x94
01598:  MOVLW  0F
0159A:  MOVWF  x96
0159C:  MOVLW  92
0159E:  MOVWF  x95
015A0:  RCALL  13B8
....................       output_low (pisos[2]); 
015A2:  MOVFF  45,93
015A6:  CLRF   x94
015A8:  MOVLW  0F
015AA:  MOVWF  x96
015AC:  MOVLW  89
015AE:  MOVWF  x95
015B0:  RCALL  13B8
015B2:  MOVFF  45,93
015B6:  CLRF   x94
015B8:  MOVLW  0F
015BA:  MOVWF  x96
015BC:  MOVLW  92
015BE:  MOVWF  x95
015C0:  RCALL  13B8
....................       output_low (pisos[3]); 
015C2:  MOVFF  47,93
015C6:  CLRF   x94
015C8:  MOVLW  0F
015CA:  MOVWF  x96
015CC:  MOVLW  89
015CE:  MOVWF  x95
015D0:  RCALL  13B8
015D2:  MOVFF  47,93
015D6:  CLRF   x94
015D8:  MOVLW  0F
015DA:  MOVWF  x96
015DC:  MOVLW  92
015DE:  MOVWF  x95
015E0:  RCALL  13B8
....................       BREAK; 
015E2:  BRA    16EC
....................  
....................       CASE 2: 
....................       output_high (pisos[2]); 
015E4:  MOVFF  45,93
015E8:  MOVLW  01
015EA:  MOVWF  x94
015EC:  MOVLW  0F
015EE:  MOVWF  x96
015F0:  MOVLW  89
015F2:  MOVWF  x95
015F4:  RCALL  13B8
015F6:  MOVFF  45,93
015FA:  CLRF   x94
015FC:  MOVLW  0F
015FE:  MOVWF  x96
01600:  MOVLW  92
01602:  MOVWF  x95
01604:  RCALL  13B8
....................       output_low (pisos[0]); 
01606:  MOVFF  41,93
0160A:  CLRF   x94
0160C:  MOVLW  0F
0160E:  MOVWF  x96
01610:  MOVLW  89
01612:  MOVWF  x95
01614:  RCALL  13B8
01616:  MOVFF  41,93
0161A:  CLRF   x94
0161C:  MOVLW  0F
0161E:  MOVWF  x96
01620:  MOVLW  92
01622:  MOVWF  x95
01624:  RCALL  13B8
....................       output_low (pisos[1]); 
01626:  MOVFF  43,93
0162A:  CLRF   x94
0162C:  MOVLW  0F
0162E:  MOVWF  x96
01630:  MOVLW  89
01632:  MOVWF  x95
01634:  RCALL  13B8
01636:  MOVFF  43,93
0163A:  CLRF   x94
0163C:  MOVLW  0F
0163E:  MOVWF  x96
01640:  MOVLW  92
01642:  MOVWF  x95
01644:  RCALL  13B8
....................       output_low (pisos[3]); 
01646:  MOVFF  47,93
0164A:  CLRF   x94
0164C:  MOVLW  0F
0164E:  MOVWF  x96
01650:  MOVLW  89
01652:  MOVWF  x95
01654:  RCALL  13B8
01656:  MOVFF  47,93
0165A:  CLRF   x94
0165C:  MOVLW  0F
0165E:  MOVWF  x96
01660:  MOVLW  92
01662:  MOVWF  x95
01664:  RCALL  13B8
....................       BREAK; 
01666:  BRA    16EC
....................  
....................       CASE 3: 
....................       output_high (pisos[3]); 
01668:  MOVFF  47,93
0166C:  MOVLW  01
0166E:  MOVWF  x94
01670:  MOVLW  0F
01672:  MOVWF  x96
01674:  MOVLW  89
01676:  MOVWF  x95
01678:  RCALL  13B8
0167A:  MOVFF  47,93
0167E:  CLRF   x94
01680:  MOVLW  0F
01682:  MOVWF  x96
01684:  MOVLW  92
01686:  MOVWF  x95
01688:  RCALL  13B8
....................       output_low (pisos[0]); 
0168A:  MOVFF  41,93
0168E:  CLRF   x94
01690:  MOVLW  0F
01692:  MOVWF  x96
01694:  MOVLW  89
01696:  MOVWF  x95
01698:  RCALL  13B8
0169A:  MOVFF  41,93
0169E:  CLRF   x94
016A0:  MOVLW  0F
016A2:  MOVWF  x96
016A4:  MOVLW  92
016A6:  MOVWF  x95
016A8:  RCALL  13B8
....................       output_low (pisos[1]); 
016AA:  MOVFF  43,93
016AE:  CLRF   x94
016B0:  MOVLW  0F
016B2:  MOVWF  x96
016B4:  MOVLW  89
016B6:  MOVWF  x95
016B8:  RCALL  13B8
016BA:  MOVFF  43,93
016BE:  CLRF   x94
016C0:  MOVLW  0F
016C2:  MOVWF  x96
016C4:  MOVLW  92
016C6:  MOVWF  x95
016C8:  RCALL  13B8
....................       output_low (pisos[2]); 
016CA:  MOVFF  45,93
016CE:  CLRF   x94
016D0:  MOVLW  0F
016D2:  MOVWF  x96
016D4:  MOVLW  89
016D6:  MOVWF  x95
016D8:  RCALL  13B8
016DA:  MOVFF  45,93
016DE:  CLRF   x94
016E0:  MOVLW  0F
016E2:  MOVWF  x96
016E4:  MOVLW  92
016E6:  MOVWF  x95
016E8:  RCALL  13B8
....................       BREAK; 
016EA:  BRA    16EC
....................    } 
.................... } 
016EC:  GOTO   171E (RETURN)
....................  
.................... void output_LEDs(INT8 nibble, int8 num_nibble, int8 level) 
.................... { 
....................    //enciede los leds por nibbles 
....................    //EJEMPLO: 
....................    //0b0001 - 0001 - 0001 - 0001 
....................    //piso4 piso3 piso2 piso1 
....................    STATIC int8 start, end; 
....................    piso (level); //Enciende el piso que se escogio 
*
01718:  MOVFF  90,91
0171C:  BRA    14CE
....................    SWITCH (num_nibble) 
....................    { 
0171E:  MOVF   x8F,W
01720:  XORLW  01
01722:  BZ    172E
01724:  XORLW  03
01726:  BZ    1738
01728:  XORLW  01
0172A:  BZ    1742
0172C:  BRA    174C
....................       CASE 1: 
....................       start = 4; end = 8; 
0172E:  MOVLW  04
01730:  MOVWF  x89
01732:  MOVLW  08
01734:  MOVWF  x8A
....................       BREAK; 
01736:  BRA    1754
....................  
....................       CASE 2: 
....................       start = 8; end = 12; 
01738:  MOVLW  08
0173A:  MOVWF  x89
0173C:  MOVLW  0C
0173E:  MOVWF  x8A
....................       BREAK; 
01740:  BRA    1754
....................  
....................       CASE 3: 
....................       start = 12; end = 16; 
01742:  MOVLW  0C
01744:  MOVWF  x89
01746:  MOVLW  10
01748:  MOVWF  x8A
....................       BREAK; 
0174A:  BRA    1754
....................  
....................       DEFAULT: 
....................       start = 0; end = 4; 
0174C:  CLRF   x89
0174E:  MOVLW  04
01750:  MOVWF  x8A
....................       BREAK; 
01752:  BRA    1754
....................    } 
....................  
....................    h = 0; 
01754:  CLRF   50
01756:  CLRF   4F
....................    FOR (i = start; i < end; i++) 
01758:  CLRF   4A
0175A:  MOVFF  89,49
0175E:  MOVF   4A,F
01760:  BNZ   17DC
01762:  MOVF   x8A,W
01764:  SUBWF  49,W
01766:  BC    17DC
....................    { 
....................       IF (bitRead (nibble, h) ) 
01768:  MOVFF  8E,91
0176C:  CLRF   x92
0176E:  MOVF   4F,W
01770:  MOVWF  00
01772:  BZ    177E
01774:  BCF    FD8.0
01776:  RRCF   x92,F
01778:  RRCF   x91,F
0177A:  DECFSZ 00,F
0177C:  BRA    1774
0177E:  MOVF   x91,W
01780:  ANDLW  01
01782:  MOVWF  00
01784:  CLRF   03
01786:  MOVF   00,W
01788:  IORWF  03,W
0178A:  BZ    17CE
....................       { 
....................          output_high (LEDS[i]); 
0178C:  BCF    FD8.0
0178E:  RLCF   49,W
01790:  MOVWF  02
01792:  RLCF   4A,W
01794:  MOVWF  03
01796:  MOVF   02,W
01798:  ADDLW  21
0179A:  MOVWF  FE9
0179C:  MOVLW  00
0179E:  ADDWFC 03,W
017A0:  MOVWF  FEA
017A2:  MOVFF  FEC,92
017A6:  MOVF   FED,F
017A8:  MOVFF  FEF,91
017AC:  MOVFF  91,93
017B0:  MOVLW  01
017B2:  MOVWF  x94
017B4:  MOVLW  0F
017B6:  MOVWF  x96
017B8:  MOVLW  89
017BA:  MOVWF  x95
017BC:  RCALL  13B8
017BE:  MOVFF  91,93
017C2:  CLRF   x94
017C4:  MOVLW  0F
017C6:  MOVWF  x96
017C8:  MOVLW  92
017CA:  MOVWF  x95
017CC:  RCALL  13B8
....................       } 
....................  
....................       h++; 
017CE:  INCF   4F,F
017D0:  BTFSC  FD8.2
017D2:  INCF   50,F
....................    } 
017D4:  INCF   49,F
017D6:  BTFSC  FD8.2
017D8:  INCF   4A,F
017DA:  BRA    175E
.................... } 
017DC:  RETURN 0
....................  
.................... int16 map(INT16 x, int16 in_min, int16 in_max, int16 out_min, int16 out_max) 
.................... { 
....................    RETURN (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; 
*
01348:  MOVF   x8E,W
0134A:  SUBWF  x8C,W
0134C:  MOVWF  x96
0134E:  MOVF   x8F,W
01350:  SUBWFB x8D,W
01352:  MOVWF  x97
01354:  MOVF   x92,W
01356:  SUBWF  x94,W
01358:  MOVWF  00
0135A:  MOVF   x93,W
0135C:  SUBWFB x95,W
0135E:  MOVWF  03
01360:  MOVFF  00,98
01364:  MOVWF  x99
01366:  MOVFF  97,9B
0136A:  MOVFF  96,9A
0136E:  MOVWF  x9D
01370:  MOVFF  00,9C
01374:  BRA    12E6
01376:  MOVFF  02,97
0137A:  MOVFF  01,96
0137E:  MOVF   x8E,W
01380:  SUBWF  x90,W
01382:  MOVWF  00
01384:  MOVF   x8F,W
01386:  SUBWFB x91,W
01388:  MOVWF  03
0138A:  MOVFF  00,98
0138E:  MOVWF  x99
01390:  MOVFF  02,9B
01394:  MOVFF  01,9A
01398:  MOVWF  x9D
0139A:  MOVFF  00,9C
0139E:  RCALL  1306
013A0:  MOVFF  02,97
013A4:  MOVFF  01,96
013A8:  MOVF   x92,W
013AA:  ADDWF  01,W
013AC:  MOVWF  01
013AE:  MOVF   x93,W
013B0:  ADDWFC 02,W
013B2:  MOVWF  03
013B4:  MOVWF  02
.................... } 
013B6:  RETURN 0
....................  
.................... void secuencia_init() 
.................... { 
....................    IF (animation == 20){ reordernar (); animation = 0; } 
*
017FE:  MOVF   5B,W
01800:  SUBLW  14
01802:  BNZ   180E
01804:  MOVF   5C,F
01806:  BNZ   180E
01808:  RCALL  10D0
0180A:  CLRF   5C
0180C:  CLRF   5B
....................    FOR (timeRefresh = 0; timeRefresh < 60; timeRefresh++) 
0180E:  CLRF   5A
01810:  CLRF   59
01812:  MOVF   5A,F
01814:  BNZ   18A0
01816:  MOVF   59,W
01818:  SUBLW  3B
0181A:  BNC   18A0
....................    { 
....................       IF (k == 3) 
0181C:  MOVF   4D,W
0181E:  SUBLW  03
01820:  BNZ   182A
01822:  MOVF   4E,F
01824:  BNZ   182A
....................       { 
....................          reverse = 1; 
01826:  BSF    x61.0
....................          }else IF (k == 0){ 
01828:  BRA    183A
0182A:  MOVF   4D,F
0182C:  BNZ   183A
0182E:  MOVF   4E,F
01830:  BNZ   183A
....................          off_leds (); 
01832:  RCALL  13F6
....................          k = 0; 
01834:  CLRF   4E
01836:  CLRF   4D
....................          reverse = 0; 
01838:  BCF    x61.0
....................       } 
....................  
....................       FOR (m = 0; m < 4; m++) 
0183A:  CLRF   52
0183C:  CLRF   51
0183E:  MOVF   52,F
01840:  BNZ   1898
01842:  MOVF   51,W
01844:  SUBLW  03
01846:  BNC   1898
....................       { 
....................           
....................          FOR (j = 0; j < 4; j++) 
01848:  CLRF   4C
0184A:  CLRF   4B
0184C:  MOVF   4C,F
0184E:  BNZ   1888
01850:  MOVF   4B,W
01852:  SUBLW  03
01854:  BNC   1888
....................          { 
....................             IF (k == - 1) 
01856:  INCFSZ 4D,W
01858:  BRA    1862
0185A:  INCFSZ 4E,W
0185C:  BRA    1862
....................             { 
....................                off_leds (); 
0185E:  RCALL  13F6
....................                }ELSE{ 
01860:  BRA    1880
....................                output_LEDS (vector[k], j, m) ; 
01862:  MOVLW  64
01864:  ADDWF  4D,W
01866:  MOVWF  FE9
01868:  MOVLW  00
0186A:  ADDWFC 4E,W
0186C:  MOVWF  FEA
0186E:  MOVFF  FEF,8B
01872:  MOVFF  8B,8E
01876:  MOVFF  4B,8F
0187A:  MOVFF  51,90
0187E:  RCALL  1718
....................             } 
....................          } 
01880:  INCF   4B,F
01882:  BTFSC  FD8.2
01884:  INCF   4C,F
01886:  BRA    184C
....................  
....................          delay_us (time); 
01888:  MOVLW  C8
0188A:  MOVWF  x8E
0188C:  RCALL  17DE
....................          off_leds (); 
0188E:  RCALL  13F6
....................       } 
01890:  INCF   51,F
01892:  BTFSC  FD8.2
01894:  INCF   52,F
01896:  BRA    183E
....................    } 
01898:  INCF   59,F
0189A:  BTFSC  FD8.2
0189C:  INCF   5A,F
0189E:  BRA    1812
....................  
....................    animation++; 
018A0:  INCF   5B,F
018A2:  BTFSC  FD8.2
018A4:  INCF   5C,F
....................  
....................    IF (reverse) 
018A6:  BTFSS  x61.0
018A8:  BRA    18B4
....................    { 
....................       k--; 
018AA:  MOVF   4D,W
018AC:  BTFSC  FD8.2
018AE:  DECF   4E,F
018B0:  DECF   4D,F
....................       }ELSE{ 
018B2:  BRA    18BA
....................       k++; 
018B4:  INCF   4D,F
018B6:  BTFSC  FD8.2
018B8:  INCF   4E,F
....................    } 
.................... } 
018BA:  GOTO   25E2 (RETURN)
....................  
.................... void LED_NUM(INT8 number,int8 m) 
.................... { 
....................    SWITCH (number) 
....................    { 
018BE:  MOVF   x8C,W
018C0:  XORLW  00
018C2:  BZ    1914
018C4:  XORLW  01
018C6:  BZ    1918
018C8:  XORLW  03
018CA:  BZ    192E
018CC:  XORLW  01
018CE:  BZ    1944
018D0:  XORLW  07
018D2:  BZ    195A
018D4:  XORLW  01
018D6:  BZ    1970
018D8:  XORLW  03
018DA:  BZ    1994
018DC:  XORLW  01
018DE:  BTFSC  FD8.2
018E0:  BRA    19C6
018E2:  XORLW  0F
018E4:  BTFSC  FD8.2
018E6:  BRA    1A06
018E8:  XORLW  01
018EA:  BTFSC  FD8.2
018EC:  BRA    1A46
018EE:  XORLW  03
018F0:  BTFSC  FD8.2
018F2:  BRA    1A86
018F4:  XORLW  01
018F6:  BTFSC  FD8.2
018F8:  BRA    1AC6
018FA:  XORLW  07
018FC:  BTFSC  FD8.2
018FE:  BRA    1B06
01900:  XORLW  01
01902:  BTFSC  FD8.2
01904:  BRA    1B46
01906:  XORLW  03
01908:  BTFSC  FD8.2
0190A:  BRA    1B86
0190C:  XORLW  01
0190E:  BTFSC  FD8.2
01910:  BRA    1BC6
01912:  BRA    1C08
....................       CASE 0: 
....................       off_leds (); 
01914:  RCALL  13F6
....................       BREAK; 
01916:  BRA    1C4A
....................  
....................       CASE 1: 
....................       output_LEDS (num[0], 0, m); 
01918:  MOVLW  01
0191A:  MOVWF  x8E
0191C:  CLRF   x8F
0191E:  MOVFF  8D,90
01922:  RCALL  1718
....................       delay_us (time); 
01924:  MOVLW  C8
01926:  MOVWF  x8E
01928:  RCALL  17DE
....................       off_leds (); 
0192A:  RCALL  13F6
....................       BREAK; 
0192C:  BRA    1C4A
....................  
....................       CASE 2: 
....................       output_LEDS (num[1], 0, m); 
0192E:  MOVLW  03
01930:  MOVWF  x8E
01932:  CLRF   x8F
01934:  MOVFF  8D,90
01938:  RCALL  1718
....................       delay_us (time); 
0193A:  MOVLW  C8
0193C:  MOVWF  x8E
0193E:  RCALL  17DE
....................       off_leds (); 
01940:  RCALL  13F6
....................       BREAK; 
01942:  BRA    1C4A
....................  
....................       CASE 3: 
....................       output_LEDS (num[2], 0, m); 
01944:  MOVLW  07
01946:  MOVWF  x8E
01948:  CLRF   x8F
0194A:  MOVFF  8D,90
0194E:  RCALL  1718
....................       delay_us (time); 
01950:  MOVLW  C8
01952:  MOVWF  x8E
01954:  RCALL  17DE
....................       off_leds (); 
01956:  RCALL  13F6
....................       BREAK; 
01958:  BRA    1C4A
....................  
....................       CASE 4: 
....................       output_LEDS (num[3], 0, m); 
0195A:  MOVLW  0F
0195C:  MOVWF  x8E
0195E:  CLRF   x8F
01960:  MOVFF  8D,90
01964:  RCALL  1718
....................       delay_us (time); 
01966:  MOVLW  C8
01968:  MOVWF  x8E
0196A:  RCALL  17DE
....................       off_leds (); 
0196C:  RCALL  13F6
....................       BREAK; 
0196E:  BRA    1C4A
....................  
....................       CASE 5: 
....................       output_LEDS (num[3], 0, m); 
01970:  MOVLW  0F
01972:  MOVWF  x8E
01974:  CLRF   x8F
01976:  MOVFF  8D,90
0197A:  RCALL  1718
....................       output_LEDS (0b1000, 1, m); 
0197C:  MOVLW  08
0197E:  MOVWF  x8E
01980:  MOVLW  01
01982:  MOVWF  x8F
01984:  MOVFF  8D,90
01988:  RCALL  1718
....................       delay_us (time); 
0198A:  MOVLW  C8
0198C:  MOVWF  x8E
0198E:  RCALL  17DE
....................       off_leds (); 
01990:  RCALL  13F6
....................       BREAK; 
01992:  BRA    1C4A
....................  
....................       CASE 6: 
....................       output_LEDS (num[3], 0, m); 
01994:  MOVLW  0F
01996:  MOVWF  x8E
01998:  CLRF   x8F
0199A:  MOVFF  8D,90
0199E:  RCALL  1718
....................       output_LEDS (0b1000, 1, m); 
019A0:  MOVLW  08
019A2:  MOVWF  x8E
019A4:  MOVLW  01
019A6:  MOVWF  x8F
019A8:  MOVFF  8D,90
019AC:  RCALL  1718
....................       output_LEDS (0b1000, 2, m); 
019AE:  MOVLW  08
019B0:  MOVWF  x8E
019B2:  MOVLW  02
019B4:  MOVWF  x8F
019B6:  MOVFF  8D,90
019BA:  RCALL  1718
....................       delay_us (time); 
019BC:  MOVLW  C8
019BE:  MOVWF  x8E
019C0:  RCALL  17DE
....................       off_leds (); 
019C2:  RCALL  13F6
....................       BREAK; 
019C4:  BRA    1C4A
....................  
....................       CASE 7: 
....................       output_LEDS (num[3], 0, m); 
019C6:  MOVLW  0F
019C8:  MOVWF  x8E
019CA:  CLRF   x8F
019CC:  MOVFF  8D,90
019D0:  RCALL  1718
....................       output_LEDS (0b1000, 1, m); 
019D2:  MOVLW  08
019D4:  MOVWF  x8E
019D6:  MOVLW  01
019D8:  MOVWF  x8F
019DA:  MOVFF  8D,90
019DE:  RCALL  1718
....................       output_LEDS (0b1000, 2, m); 
019E0:  MOVLW  08
019E2:  MOVWF  x8E
019E4:  MOVLW  02
019E6:  MOVWF  x8F
019E8:  MOVFF  8D,90
019EC:  RCALL  1718
....................       output_LEDS (0b1000, 3, m); 
019EE:  MOVLW  08
019F0:  MOVWF  x8E
019F2:  MOVLW  03
019F4:  MOVWF  x8F
019F6:  MOVFF  8D,90
019FA:  RCALL  1718
....................       delay_us (time); 
019FC:  MOVLW  C8
019FE:  MOVWF  x8E
01A00:  RCALL  17DE
....................       off_leds (); 
01A02:  RCALL  13F6
....................       BREAK; 
01A04:  BRA    1C4A
....................  
....................       CASE 8: 
....................       output_LEDS (num[3], 0, m); 
01A06:  MOVLW  0F
01A08:  MOVWF  x8E
01A0A:  CLRF   x8F
01A0C:  MOVFF  8D,90
01A10:  RCALL  1718
....................       output_LEDS (0b1000, 1, m); 
01A12:  MOVLW  08
01A14:  MOVWF  x8E
01A16:  MOVLW  01
01A18:  MOVWF  x8F
01A1A:  MOVFF  8D,90
01A1E:  RCALL  1718
....................       output_LEDS (0b1000, 2, m); 
01A20:  MOVLW  08
01A22:  MOVWF  x8E
01A24:  MOVLW  02
01A26:  MOVWF  x8F
01A28:  MOVFF  8D,90
01A2C:  RCALL  1718
....................       output_LEDS (0b1100, 3, m); 
01A2E:  MOVLW  0C
01A30:  MOVWF  x8E
01A32:  MOVLW  03
01A34:  MOVWF  x8F
01A36:  MOVFF  8D,90
01A3A:  RCALL  1718
....................       delay_us (time); 
01A3C:  MOVLW  C8
01A3E:  MOVWF  x8E
01A40:  RCALL  17DE
....................       off_leds (); 
01A42:  RCALL  13F6
....................       BREAK; 
01A44:  BRA    1C4A
....................  
....................       CASE 9: 
....................       output_LEDS (num[3], 0, m); 
01A46:  MOVLW  0F
01A48:  MOVWF  x8E
01A4A:  CLRF   x8F
01A4C:  MOVFF  8D,90
01A50:  RCALL  1718
....................       output_LEDS (0b1000, 1, m); 
01A52:  MOVLW  08
01A54:  MOVWF  x8E
01A56:  MOVLW  01
01A58:  MOVWF  x8F
01A5A:  MOVFF  8D,90
01A5E:  RCALL  1718
....................       output_LEDS (0b1000, 2, m); 
01A60:  MOVLW  08
01A62:  MOVWF  x8E
01A64:  MOVLW  02
01A66:  MOVWF  x8F
01A68:  MOVFF  8D,90
01A6C:  RCALL  1718
....................       output_LEDS (0b1110, 3, m); 
01A6E:  MOVLW  0E
01A70:  MOVWF  x8E
01A72:  MOVLW  03
01A74:  MOVWF  x8F
01A76:  MOVFF  8D,90
01A7A:  RCALL  1718
....................       delay_us (time); 
01A7C:  MOVLW  C8
01A7E:  MOVWF  x8E
01A80:  RCALL  17DE
....................       off_leds (); 
01A82:  RCALL  13F6
....................       BREAK; 
01A84:  BRA    1C4A
....................  
....................       CASE 10: 
....................       output_LEDS (num[3], 0, m); 
01A86:  MOVLW  0F
01A88:  MOVWF  x8E
01A8A:  CLRF   x8F
01A8C:  MOVFF  8D,90
01A90:  RCALL  1718
....................       output_LEDS (0b1000, 1, m); 
01A92:  MOVLW  08
01A94:  MOVWF  x8E
01A96:  MOVLW  01
01A98:  MOVWF  x8F
01A9A:  MOVFF  8D,90
01A9E:  RCALL  1718
....................       output_LEDS (0b1000, 2, m); 
01AA0:  MOVLW  08
01AA2:  MOVWF  x8E
01AA4:  MOVLW  02
01AA6:  MOVWF  x8F
01AA8:  MOVFF  8D,90
01AAC:  RCALL  1718
....................       output_LEDS (0b1111, 3, m); 
01AAE:  MOVLW  0F
01AB0:  MOVWF  x8E
01AB2:  MOVLW  03
01AB4:  MOVWF  x8F
01AB6:  MOVFF  8D,90
01ABA:  RCALL  1718
....................       delay_us (time); 
01ABC:  MOVLW  C8
01ABE:  MOVWF  x8E
01AC0:  RCALL  17DE
....................       off_leds (); 
01AC2:  RCALL  13F6
....................       BREAK; 
01AC4:  BRA    1C4A
....................  
....................       CASE 11: 
....................       output_LEDS (num[3], 0, m); 
01AC6:  MOVLW  0F
01AC8:  MOVWF  x8E
01ACA:  CLRF   x8F
01ACC:  MOVFF  8D,90
01AD0:  RCALL  1718
....................       output_LEDS (0b1000, 1, m); 
01AD2:  MOVLW  08
01AD4:  MOVWF  x8E
01AD6:  MOVLW  01
01AD8:  MOVWF  x8F
01ADA:  MOVFF  8D,90
01ADE:  RCALL  1718
....................       output_LEDS (0b1001, 2, m); 
01AE0:  MOVLW  09
01AE2:  MOVWF  x8E
01AE4:  MOVLW  02
01AE6:  MOVWF  x8F
01AE8:  MOVFF  8D,90
01AEC:  RCALL  1718
....................       output_LEDS (0b1111, 3, m); 
01AEE:  MOVLW  0F
01AF0:  MOVWF  x8E
01AF2:  MOVLW  03
01AF4:  MOVWF  x8F
01AF6:  MOVFF  8D,90
01AFA:  RCALL  1718
....................       delay_us (time); 
01AFC:  MOVLW  C8
01AFE:  MOVWF  x8E
01B00:  RCALL  17DE
....................       off_leds (); 
01B02:  RCALL  13F6
....................       BREAK; 
01B04:  BRA    1C4A
....................  
....................       CASE 12: 
....................       output_LEDS (num[3], 0, m); 
01B06:  MOVLW  0F
01B08:  MOVWF  x8E
01B0A:  CLRF   x8F
01B0C:  MOVFF  8D,90
01B10:  RCALL  1718
....................       output_LEDS (0b1001, 1, m); 
01B12:  MOVLW  09
01B14:  MOVWF  x8E
01B16:  MOVLW  01
01B18:  MOVWF  x8F
01B1A:  MOVFF  8D,90
01B1E:  RCALL  1718
....................       output_LEDS (0b1001, 2, m); 
01B20:  MOVLW  09
01B22:  MOVWF  x8E
01B24:  MOVLW  02
01B26:  MOVWF  x8F
01B28:  MOVFF  8D,90
01B2C:  RCALL  1718
....................       output_LEDS (0b1111, 3, m); 
01B2E:  MOVLW  0F
01B30:  MOVWF  x8E
01B32:  MOVLW  03
01B34:  MOVWF  x8F
01B36:  MOVFF  8D,90
01B3A:  RCALL  1718
....................       delay_us (time); 
01B3C:  MOVLW  C8
01B3E:  MOVWF  x8E
01B40:  RCALL  17DE
....................       off_leds (); 
01B42:  RCALL  13F6
....................       BREAK; 
01B44:  BRA    1C4A
....................  
....................       CASE 13: 
....................       output_LEDS (num[3], 0, m); 
01B46:  MOVLW  0F
01B48:  MOVWF  x8E
01B4A:  CLRF   x8F
01B4C:  MOVFF  8D,90
01B50:  RCALL  1718
....................       output_LEDS (0b1011, 1, m); 
01B52:  MOVLW  0B
01B54:  MOVWF  x8E
01B56:  MOVLW  01
01B58:  MOVWF  x8F
01B5A:  MOVFF  8D,90
01B5E:  RCALL  1718
....................       output_LEDS (0b1001, 2, m); 
01B60:  MOVLW  09
01B62:  MOVWF  x8E
01B64:  MOVLW  02
01B66:  MOVWF  x8F
01B68:  MOVFF  8D,90
01B6C:  RCALL  1718
....................       output_LEDS (0b1111, 3, m); 
01B6E:  MOVLW  0F
01B70:  MOVWF  x8E
01B72:  MOVLW  03
01B74:  MOVWF  x8F
01B76:  MOVFF  8D,90
01B7A:  RCALL  1718
....................       delay_us (time); 
01B7C:  MOVLW  C8
01B7E:  MOVWF  x8E
01B80:  RCALL  17DE
....................       off_leds (); 
01B82:  RCALL  13F6
....................       BREAK; 
01B84:  BRA    1C4A
....................  
....................       CASE 14: 
....................       output_LEDS (num[3], 0, m); 
01B86:  MOVLW  0F
01B88:  MOVWF  x8E
01B8A:  CLRF   x8F
01B8C:  MOVFF  8D,90
01B90:  RCALL  1718
....................       output_LEDS (0b1111, 1, m); 
01B92:  MOVLW  0F
01B94:  MOVWF  x8E
01B96:  MOVLW  01
01B98:  MOVWF  x8F
01B9A:  MOVFF  8D,90
01B9E:  RCALL  1718
....................       output_LEDS (0b1001, 2, m); 
01BA0:  MOVLW  09
01BA2:  MOVWF  x8E
01BA4:  MOVLW  02
01BA6:  MOVWF  x8F
01BA8:  MOVFF  8D,90
01BAC:  RCALL  1718
....................       output_LEDS (0b1111, 3, m); 
01BAE:  MOVLW  0F
01BB0:  MOVWF  x8E
01BB2:  MOVLW  03
01BB4:  MOVWF  x8F
01BB6:  MOVFF  8D,90
01BBA:  RCALL  1718
....................       delay_us (time); 
01BBC:  MOVLW  C8
01BBE:  MOVWF  x8E
01BC0:  RCALL  17DE
....................       off_leds (); 
01BC2:  RCALL  13F6
....................       BREAK; 
01BC4:  BRA    1C4A
....................  
....................       CASE 15: 
....................       output_LEDS (num[3], 0, m); 
01BC6:  MOVLW  0F
01BC8:  MOVWF  x8E
01BCA:  CLRF   x8F
01BCC:  MOVFF  8D,90
01BD0:  RCALL  1718
....................       output_LEDS (0b1111, 1, m); 
01BD2:  MOVLW  0F
01BD4:  MOVWF  x8E
01BD6:  MOVLW  01
01BD8:  MOVWF  x8F
01BDA:  MOVFF  8D,90
01BDE:  RCALL  1718
....................       output_LEDS (0b1101, 2, m); 
01BE0:  MOVLW  0D
01BE2:  MOVWF  x8E
01BE4:  MOVLW  02
01BE6:  MOVWF  x8F
01BE8:  MOVFF  8D,90
01BEC:  RCALL  1718
....................       output_LEDS (0b1111, 3, m); 
01BEE:  MOVLW  0F
01BF0:  MOVWF  x8E
01BF2:  MOVLW  03
01BF4:  MOVWF  x8F
01BF6:  MOVFF  8D,90
01BFA:  RCALL  1718
....................       delay_us (time); 
01BFC:  MOVLW  C8
01BFE:  MOVWF  x8E
01C00:  RCALL  17DE
....................       off_leds (); 
01C02:  CALL   13F6
....................       BREAK; 
01C06:  BRA    1C4A
....................  
....................       DEFAULT: 
....................       output_LEDS (num[3], 0, m); 
01C08:  MOVLW  0F
01C0A:  MOVWF  x8E
01C0C:  CLRF   x8F
01C0E:  MOVFF  8D,90
01C12:  RCALL  1718
....................       output_LEDS (0b1111, 1, m); 
01C14:  MOVLW  0F
01C16:  MOVWF  x8E
01C18:  MOVLW  01
01C1A:  MOVWF  x8F
01C1C:  MOVFF  8D,90
01C20:  RCALL  1718
....................       output_LEDS (0b1111, 2, m); 
01C22:  MOVLW  0F
01C24:  MOVWF  x8E
01C26:  MOVLW  02
01C28:  MOVWF  x8F
01C2A:  MOVFF  8D,90
01C2E:  RCALL  1718
....................       output_LEDS (0b1111, 3, m); 
01C30:  MOVLW  0F
01C32:  MOVWF  x8E
01C34:  MOVLW  03
01C36:  MOVWF  x8F
01C38:  MOVFF  8D,90
01C3C:  RCALL  1718
....................       delay_us (time); 
01C3E:  MOVLW  C8
01C40:  MOVWF  x8E
01C42:  RCALL  17DE
....................       off_leds (); 
01C44:  CALL   13F6
....................       BREAK; 
01C48:  BRA    1C4A
....................    } 
.................... } 
01C4A:  RETURN 0
....................  
.................... #INT_TIMER0 
....................  
.................... void  TIMER0_isr(VOID)//Funcin de interrupcin por desbordamiento TMR1   
.................... { 
....................    output_toggle (PIN_D1); 
*
010BE:  BCF    F95.1
010C0:  BTG    F8C.1
....................  
....................     
....................    set_timer0 (65000); 
010C2:  MOVLW  FD
010C4:  MOVWF  FD7
010C6:  MOVLW  E8
010C8:  MOVWF  FD6
.................... } 
....................  
.................... /******************************************************************************/ 
.................... /******************************************************************************/ 
.................... /*--------------------- Espacio de codigo principal --------------------------*/ 
.................... /******************************************************************************/  
.................... #zero_ram 
....................  
010CA:  BCF    FF2.2
010CC:  GOTO   1068
.................... void main() 
.................... { 
*
023BA:  CLRF   FF8
023BC:  BCF    FD0.7
023BE:  BSF    07.7
023C0:  MOVLB  E
023C2:  MOVLW  55
023C4:  MOVWF  FA7
023C6:  MOVLW  AA
023C8:  MOVWF  FA7
023CA:  BCF    xBF.0
023CC:  MOVLW  14
023CE:  MOVWF  xF7
023D0:  MOVLW  06
023D2:  MOVWF  xD3
023D4:  MOVLW  55
023D6:  MOVWF  FA7
023D8:  MOVLW  AA
023DA:  MOVWF  FA7
023DC:  BSF    xBF.0
023DE:  MOVLW  AE
023E0:  MOVWF  00
023E2:  MOVLW  0F
023E4:  MOVWF  01
023E6:  MOVLW  02
023E8:  MOVWF  FE9
023EA:  MOVLW  00
023EC:  MOVWF  FEA
023EE:  CLRF   FEE
023F0:  DECFSZ 00,F
023F2:  BRA    23EE
023F4:  DECFSZ 01,F
023F6:  BRA    23EE
023F8:  CLRF   FEA
023FA:  CLRF   FE9
023FC:  CLRF   4A
023FE:  CLRF   49
02400:  CLRF   4C
02402:  CLRF   4B
02404:  CLRF   4E
02406:  CLRF   4D
02408:  CLRF   50
0240A:  CLRF   4F
0240C:  CLRF   52
0240E:  CLRF   51
02410:  CLRF   58
02412:  CLRF   57
02414:  CLRF   5A
02416:  CLRF   59
02418:  CLRF   5C
0241A:  CLRF   5B
0241C:  MOVLB  0
0241E:  BCF    x61.0
02420:  BCF    x61.1
02422:  BCF    x61.2
02424:  BSF    x61.3
02426:  CLRF   x62
02428:  CLRF   x63
0242A:  MOVLB  1
0242C:  CLRF   x88
0242E:  MOVLW  FF
02430:  MOVLB  F
02432:  MOVWF  x48
02434:  BCF    FC2.6
02436:  BCF    FC2.7
02438:  MOVF   x49,W
0243A:  ANDLW  E0
0243C:  IORLW  1F
0243E:  MOVWF  x49
02440:  CLRF   x25
02442:  CLRF   FD1
02444:  CLRF   FD2
02446:  CLRF   1B
02448:  CLRF   1C
0244A:  MOVLW  11
0244C:  MOVWF  21
0244E:  MOVLW  7C
02450:  MOVWF  22
02452:  MOVLW  12
02454:  MOVWF  23
02456:  MOVLW  7C
02458:  MOVWF  24
0245A:  MOVLW  16
0245C:  MOVWF  25
0245E:  MOVLW  7C
02460:  MOVWF  26
02462:  MOVLW  17
02464:  MOVWF  27
02466:  MOVLW  7C
02468:  MOVWF  28
0246A:  MOVLW  1D
0246C:  MOVWF  29
0246E:  MOVLW  7C
02470:  MOVWF  2A
02472:  MOVLW  1E
02474:  MOVWF  2B
02476:  MOVLW  7C
02478:  MOVWF  2C
0247A:  MOVLW  1F
0247C:  MOVWF  2D
0247E:  MOVLW  7C
02480:  MOVWF  2E
02482:  MOVLW  10
02484:  MOVWF  2F
02486:  MOVLW  7C
02488:  MOVWF  30
0248A:  MOVLW  1C
0248C:  MOVWF  31
0248E:  MOVLW  7C
02490:  MOVWF  32
02492:  MOVLW  1B
02494:  MOVWF  33
02496:  MOVLW  7C
02498:  MOVWF  34
0249A:  MOVLW  1A
0249C:  MOVWF  35
0249E:  MOVLW  7C
024A0:  MOVWF  36
024A2:  MOVLW  20
024A4:  MOVWF  37
024A6:  MOVLW  7C
024A8:  MOVWF  38
024AA:  MOVLW  21
024AC:  MOVWF  39
024AE:  MOVLW  7C
024B0:  MOVWF  3A
024B2:  MOVLW  22
024B4:  MOVWF  3B
024B6:  MOVLW  7C
024B8:  MOVWF  3C
024BA:  MOVLW  08
024BC:  MOVWF  3D
024BE:  MOVLW  7C
024C0:  MOVWF  3E
024C2:  MOVLW  09
024C4:  MOVWF  3F
024C6:  MOVLW  7C
024C8:  MOVWF  40
024CA:  MOVLW  0F
024CC:  MOVWF  41
024CE:  MOVLW  7C
024D0:  MOVWF  42
024D2:  MOVLW  0E
024D4:  MOVWF  43
024D6:  MOVLW  7C
024D8:  MOVWF  44
024DA:  MOVLW  0D
024DC:  MOVWF  45
024DE:  MOVLW  7C
024E0:  MOVWF  46
024E2:  MOVLW  0C
024E4:  MOVWF  47
024E6:  MOVLW  7C
024E8:  MOVWF  48
024EA:  MOVLW  01
024EC:  MOVLB  0
024EE:  MOVWF  x64
024F0:  MOVLW  02
024F2:  MOVWF  x65
024F4:  MOVLW  04
024F6:  MOVWF  x66
024F8:  MOVLW  08
024FA:  MOVWF  x67
024FC:  CLRF   x68
024FE:  CLRF   x69
02500:  CLRF   x6A
02502:  CLRF   x6B
02504:  CLRF   x6C
02506:  CLRF   x6D
02508:  CLRF   x6E
0250A:  CLRF   x6F
0250C:  CLRF   x70
0250E:  CLRF   x71
02510:  CLRF   x72
02512:  CLRF   x73
02514:  CLRF   x74
02516:  CLRF   x75
02518:  CLRF   x76
0251A:  CLRF   x77
0251C:  CLRF   x78
0251E:  CLRF   x79
02520:  CLRF   x7A
02522:  CLRF   x7B
02524:  CLRF   x7C
02526:  CLRF   x7D
02528:  CLRF   x7E
0252A:  CLRF   x7F
0252C:  CLRF   x80
0252E:  CLRF   x81
02530:  CLRF   x82
02532:  CLRF   x83
02534:  CLRF   x84
02536:  CLRF   x85
02538:  CLRF   x86
0253A:  CLRF   x87
0253C:  CLRF   x88
0253E:  CLRF   x89
02540:  CLRF   x8A
....................    // Inicializa microcontrolador 
....................    mcu_init (); 
02542:  BSF    F9B.6
....................    setup_adc_ports (sAN9); 
02544:  MOVLW  FF
02546:  MOVLB  F
02548:  MOVWF  x48
0254A:  BCF    FC2.6
0254C:  BCF    FC2.7
0254E:  MOVF   x49,W
02550:  ANDLW  E0
02552:  IORLW  1D
02554:  MOVWF  x49
....................    setup_adc (ADC_CLOCK_INTERNAL); 
02556:  MOVF   FC1,W
02558:  ANDLW  C0
0255A:  IORLW  03
0255C:  MOVWF  FC1
0255E:  BCF    FC1.7
02560:  BSF    FC2.0
02562:  BSF    FC2.7
02564:  BSF    FC2.1
02566:  BTFSC  FC2.1
02568:  BRA    2566
0256A:  BCF    FC2.7
....................    setup_timer_0 (RTCC_INTERNAL|RTCC_DIV_64); 
0256C:  MOVLW  85
0256E:  MOVWF  FD5
....................    enable_interrupts (GLOBAL); //Habilito interrupciones globales 
02570:  MOVLW  C0
02572:  IORWF  FF2,F
....................    FOR (;;) 
....................    { 
....................       IF ( ! input (PIN_D0)) 
02574:  BSF    F95.0
02576:  BTFSC  F83.0
02578:  BRA    259C
....................       { 
....................          enable_interrupts (INT_TIMER0); 
0257A:  BSF    FF2.5
....................          m = j = i = 0; 
0257C:  CLRF   4A
0257E:  CLRF   49
02580:  MOVFF  4A,4C
02584:  MOVFF  49,4B
02588:  MOVFF  4C,52
0258C:  MOVFF  4B,51
....................          enable = 1; 
02590:  MOVLB  0
02592:  BSF    x61.2
....................  
....................          DO 
....................          { 
....................             reordernar (); 
02594:  CALL   10D0
....................          }WHILE ( ! positionBits) ; 
02598:  BTFSS  x61.3
0259A:  BRA    2594
....................       } 
....................  
....................       IF ( ! enable) 
0259C:  MOVLB  0
0259E:  BTFSC  x61.2
025A0:  BRA    25E4
....................       { 
....................          set_adc_channel (9); // Inicia lectura por ADC canal 3 PinA3 
025A2:  MOVLW  24
025A4:  MOVWF  01
025A6:  MOVF   FC2,W
025A8:  ANDLW  C3
025AA:  IORWF  01,W
025AC:  MOVWF  FC2
....................          speed = map (read_adc (), 0, 255, 1, 100) ; // Guarda en variable el resultado del ADC y hace regla de tres 
025AE:  BSF    FC2.1
025B0:  BTFSC  FC2.1
025B2:  BRA    25B0
025B4:  MOVFF  FC4,8B
025B8:  CLRF   x8D
025BA:  MOVFF  FC4,8C
025BE:  CLRF   x8F
025C0:  CLRF   x8E
025C2:  CLRF   x91
025C4:  SETF   x90
025C6:  CLRF   x93
025C8:  MOVLW  01
025CA:  MOVWF  x92
025CC:  CLRF   x95
025CE:  MOVLW  64
025D0:  MOVWF  x94
025D2:  CALL   1348
025D6:  MOVFF  02,56
025DA:  MOVFF  01,55
....................          secuencia_init (); //Secuencia de inicio 
025DE:  GOTO   17FE
....................          }ELSE{ 
025E2:  BRA    2832
....................  
....................                set_adc_channel (9); // Inicia lectura por ADC canal 3 PinA3 
025E4:  MOVLW  24
025E6:  MOVWF  01
025E8:  MOVF   FC2,W
025EA:  ANDLW  C3
025EC:  IORWF  01,W
025EE:  MOVWF  FC2
....................          signalMax = 0; 
025F0:  CLRF   x62
....................          signalMin = 255; 
025F2:  SETF   x63
....................          peaktoPeak=0; 
025F4:  CLRF   x60
025F6:  CLRF   5F
....................           mic=0; 
025F8:  CLRF   58
025FA:  CLRF   57
....................     WHILE (mic < 20) 
....................          { 
025FC:  MOVF   58,F
025FE:  BNZ   2642
02600:  MOVF   57,W
02602:  SUBLW  13
02604:  BNC   2642
....................            sample = read_adc(); 
02606:  BSF    FC2.1
02608:  BTFSC  FC2.1
0260A:  BRA    2608
0260C:  MOVF   FC4,W
0260E:  CLRF   5E
02610:  MOVWF  5D
....................             IF (sample < 255) // toss out spurious readings 
02612:  MOVF   5E,F
02614:  BNZ   263A
02616:  MOVF   5D,W
02618:  SUBLW  FE
0261A:  BNC   263A
....................             { 
....................                IF (sample > signalMax) 
0261C:  MOVF   5E,F
0261E:  BNZ   2626
02620:  MOVF   5D,W
02622:  SUBWF  x62,W
02624:  BC    262C
....................                { 
....................                   signalMax = sample; // save just the max levels 
02626:  MOVFF  5D,62
....................                } 
....................  
....................                else IF (sample < signalMin) 
0262A:  BRA    263A
0262C:  MOVF   5E,F
0262E:  BNZ   263A
02630:  MOVF   x63,W
02632:  SUBWF  5D,W
02634:  BC    263A
....................                { 
....................                   signalMin = sample; // save just the min levels 
02636:  MOVFF  5D,63
....................                } 
....................             } 
....................  
....................             mic++; 
0263A:  INCF   57,F
0263C:  BTFSC  FD8.2
0263E:  INCF   58,F
....................          } 
02640:  BRA    25FC
....................          peakToPeak = signalMax - signalMin; 
02642:  MOVF   x63,W
02644:  SUBWF  x62,W
02646:  MOVWF  5F
02648:  CLRF   x60
....................          sound = map (peaktoPeak, 0, 255,0,80) ; 
0264A:  MOVFF  60,8D
0264E:  MOVFF  5F,8C
02652:  CLRF   x8F
02654:  CLRF   x8E
02656:  CLRF   x91
02658:  SETF   x90
0265A:  CLRF   x93
0265C:  CLRF   x92
0265E:  CLRF   x95
02660:  MOVLW  50
02662:  MOVWF  x94
02664:  CALL   1348
02668:  MOVFF  02,54
0266C:  MOVFF  01,53
....................          sound = constrain(sound,0,80); 
02670:  MOVF   54,F
02672:  BNZ   267A
02674:  MOVF   53,W
02676:  SUBLW  50
02678:  BC    2680
0267A:  CLRF   03
0267C:  MOVLW  50
0267E:  BRA    2686
02680:  MOVFF  54,03
02684:  MOVF   53,W
02686:  MOVWF  53
02688:  MOVFF  03,54
....................   
....................          off_leds(); 
0268C:  CALL   13F6
....................          IF (sound <= 16) 
02690:  MOVF   54,F
02692:  BNZ   26A4
02694:  MOVF   53,W
02696:  SUBLW  10
02698:  BNC   26A4
....................          { 
....................             LED_NUM (sound, 0) ; 
0269A:  MOVFF  53,8C
0269E:  CLRF   x8D
026A0:  CALL   18BE
....................             } 
....................             IF (sound <= 32){ 
026A4:  MOVF   54,F
026A6:  BNZ   2712
026A8:  MOVF   53,W
026AA:  SUBLW  20
026AC:  BNC   2712
....................             LED_NUM (16, 0) ; 
026AE:  MOVLW  10
026B0:  MOVWF  x8C
026B2:  CLRF   x8D
026B4:  CALL   18BE
....................             LED_NUM (floor (sound / 2), 1) ; 
026B8:  BCF    FD8.0
026BA:  RRCF   54,W
026BC:  MOVWF  03
026BE:  RRCF   53,W
026C0:  MOVWF  02
026C2:  MOVWF  xA7
026C4:  MOVFF  03,A8
026C8:  CALL   1C4C
026CC:  MOVFF  00,8B
026D0:  MOVFF  01,8C
026D4:  MOVFF  02,8D
026D8:  MOVFF  03,8E
026DC:  MOVFF  03,92
026E0:  MOVFF  02,91
026E4:  MOVFF  01,90
026E8:  MOVFF  00,8F
026EC:  RCALL  23A4
026EE:  MOVFF  03,A6
026F2:  MOVFF  02,A5
026F6:  MOVFF  01,A4
026FA:  MOVFF  00,A3
026FE:  CALL   1CF8
02702:  MOVFF  01,8B
02706:  MOVFF  01,8C
0270A:  MOVLW  01
0270C:  MOVWF  x8D
0270E:  CALL   18BE
....................             } 
....................             IF (sound <= 48){ 
02712:  MOVF   54,F
02714:  BNZ   279A
02716:  MOVF   53,W
02718:  SUBLW  30
0271A:  BNC   279A
....................             LED_NUM (16, 0) ; 
0271C:  MOVLW  10
0271E:  MOVWF  x8C
02720:  CLRF   x8D
02722:  CALL   18BE
....................             LED_NUM (16, 1) ; 
02726:  MOVLW  10
02728:  MOVWF  x8C
0272A:  MOVLW  01
0272C:  MOVWF  x8D
0272E:  CALL   18BE
....................             LED_NUM (floor (sound / 3), 2) ; 
02732:  MOVFF  54,9B
02736:  MOVFF  53,9A
0273A:  CLRF   x9D
0273C:  MOVLW  03
0273E:  MOVWF  x9C
02740:  CALL   1306
02744:  MOVFF  02,03
02748:  MOVFF  01,A7
0274C:  MOVFF  02,A8
02750:  CALL   1C4C
02754:  MOVFF  00,8B
02758:  MOVFF  01,8C
0275C:  MOVFF  02,8D
02760:  MOVFF  03,8E
02764:  MOVFF  03,92
02768:  MOVFF  02,91
0276C:  MOVFF  01,90
02770:  MOVFF  00,8F
02774:  RCALL  23A4
02776:  MOVFF  03,A6
0277A:  MOVFF  02,A5
0277E:  MOVFF  01,A4
02782:  MOVFF  00,A3
02786:  CALL   1CF8
0278A:  MOVFF  01,8B
0278E:  MOVFF  01,8C
02792:  MOVLW  02
02794:  MOVWF  x8D
02796:  CALL   18BE
....................             } 
....................             IF (sound <= 64 && sound >=64 ){ 
0279A:  MOVF   54,F
0279C:  BNZ   2832
0279E:  MOVF   53,W
027A0:  SUBLW  40
027A2:  BNC   2832
027A4:  MOVF   54,F
027A6:  BNZ   27AE
027A8:  MOVF   53,W
027AA:  SUBLW  3F
027AC:  BC    2832
....................             LED_NUM (16, 0) ; 
027AE:  MOVLW  10
027B0:  MOVWF  x8C
027B2:  CLRF   x8D
027B4:  CALL   18BE
....................             LED_NUM (16, 1) ; 
027B8:  MOVLW  10
027BA:  MOVWF  x8C
027BC:  MOVLW  01
027BE:  MOVWF  x8D
027C0:  CALL   18BE
....................             LED_NUM (16, 2) ; 
027C4:  MOVLW  10
027C6:  MOVWF  x8C
027C8:  MOVLW  02
027CA:  MOVWF  x8D
027CC:  CALL   18BE
....................             LED_NUM (floor (sound / 4), 3) ; 
027D0:  RRCF   54,W
027D2:  MOVWF  03
027D4:  RRCF   53,W
027D6:  MOVWF  02
027D8:  RRCF   03,F
027DA:  RRCF   02,F
027DC:  MOVLW  3F
027DE:  ANDWF  03,F
027E0:  MOVFF  02,A7
027E4:  MOVFF  03,A8
027E8:  CALL   1C4C
027EC:  MOVFF  00,8B
027F0:  MOVFF  01,8C
027F4:  MOVFF  02,8D
027F8:  MOVFF  03,8E
027FC:  MOVFF  03,92
02800:  MOVFF  02,91
02804:  MOVFF  01,90
02808:  MOVFF  00,8F
0280C:  RCALL  23A4
0280E:  MOVFF  03,A6
02812:  MOVFF  02,A5
02816:  MOVFF  01,A4
0281A:  MOVFF  00,A3
0281E:  CALL   1CF8
02822:  MOVFF  01,8B
02826:  MOVFF  01,8C
0282A:  MOVLW  03
0282C:  MOVWF  x8D
0282E:  CALL   18BE
....................          } 
....................       } 
....................  
....................    } 
02832:  MOVLB  F
02834:  BRA    2574
.................... } 
....................  
02836:  SLEEP 

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: F980   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
